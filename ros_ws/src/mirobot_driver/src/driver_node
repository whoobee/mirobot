#!/usr/bin/env python

import rospy
from geometry_msgs.msg import Twist
from mirobot_driver.msg import wheel_control

_FREQUENCY = 20

def _clip(value, minimum, maximum):
    """Ensure value is between minimum and maximum."""

    if value < minimum:
        return minimum
    elif value > maximum:
        return maximum
    return value

class Driver:

    def __init__(self):
        rospy.init_node('driver')

        self._last_received = rospy.get_time()
        self._timeout = rospy.get_param('~timeout', 2)
        self._rate = rospy.get_param('~rate', 10)
        self._max_speed = rospy.get_param('~max_speed', 0.5)
        self._wheel_base = rospy.get_param('~wheel_base', 0.17)

        self._left_speed_percent = 0
        self._right_speed_percent = 0

        # Setup subscriber for velocity twist message
        self.sub = rospy.Subscriber(
            'cmd_vel', Twist, self.velocity_received_callback)

        # Setup publisher for motor control message
        self.pub = rospy.Publisher(
            'wheel_ctrl', wheel_control, queue_size=256)
        
        self.wheel_data = wheel_control()


    def velocity_received_callback(self, message):
        """Handle new velocity command message."""

        self._last_received = rospy.get_time()

        # Extract linear and angular velocities from the message
        linear = message.linear.x
        angular = message.angular.z

        # Calculate wheel speeds in m/s
        left_speed = linear - angular*self._wheel_base/2
        right_speed = linear + angular*self._wheel_base/2

        # Ideally we'd now use the desired wheel speeds along
        # with data from wheel speed sensors to come up with the
        # power we need to apply to the wheels, but we don't have
        # wheel speed sensors. Instead, we'll simply convert m/s
        # into percent of maximum wheel speed, which gives us a
        # duty cycle that we can apply to each motor.
        self._left_speed_percent = (100 * left_speed/self._max_speed)
        self._right_speed_percent = (100 * right_speed/self._max_speed)
        
        if self._left_speed_percent > 0:
            self.wheel_data.dir_l = 0
            self.wheel_data.speed_l = self._left_speed_percent
        else:
            self.wheel_data.dir_l = 1
            self.wheel_data.speed_l = -self._left_speed_percent
            
        if self._right_speed_percent > 0:
            self.wheel_data.dir_r = 0
            self.wheel_data.speed_r = self._right_speed_percent
        else:
            self.wheel_data.dir_r = 1
            self.wheel_data.speed_r = -self._right_speed_percent

    def run(self):
        """The control loop of the driver."""
        rate = rospy.Rate(self._rate)

        while not rospy.is_shutdown():
            # If we haven't received new commands for a while, we
            # may have lost contact with the commander-- stop
            # moving
				delay = rospy.get_time() - self._last_received
				if delay > self._timeout:
					self.wheel_data.speed_l = 0
					self.wheel_data.speed_r = 0
				self.pub.publish(self.wheel_data)
				rate.sleep()

def main():
    driver = Driver()

    # Run driver. This will block
    driver.run()

if __name__ == '__main__':
    main()
